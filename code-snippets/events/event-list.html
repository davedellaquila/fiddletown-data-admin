<!-- 
  SSA Events Widget - Squarespace Code Injection
  
  This widget fetches events from a Supabase database and displays them with filtering and layout options.
  Features:
  - Fetches upcoming events from the 'events' table
  - Multiple layout options: list (by month), grid tiles
  - Keyword filtering
  - Date range filtering (from/to dates)
  - Includes caching for better performance
  - Handles loading states and error conditions
  
  Usage: Include this code in Squarespace Code Injection and it will render events in the #events-list div
-->

<!-- 1) One-time: widget script -->
<script>
(function() {
  function todayISO() { const d=new Date(); d.setHours(0,0,0,0); return d.toISOString().slice(0,10); }

  // Layout types
  const LAYOUTS = {
    LIST: 'list',
    GRID: 'grid'
  };

  async function fetchEvents({ url, key, from = null, to = null, limit = 200 }) {
      const api = new URL(url + '/rest/v1/events');
      api.searchParams.set('select','id,name,slug,host_org,start_date,end_date,location,website_url,image_url,recurrence,sort_order,description');
      api.searchParams.set('order','start_date.asc,name.asc');
      api.searchParams.set('limit', String(limit));

	  // Show upcoming events if FROM is set.
	  // Include rows where:
	  //  - end_date >= from  OR
	  //  - start_date >= from  OR
	  //  - both dates are null (undated events)
	  if (from) {
	    // IMPORTANT: wrap conditions in parentheses
	    const orFilter =
	      `(end_date.gte.${from},start_date.gte.${from},and(start_date.is.null,end_date.is.null))`;
	    api.searchParams.set('or', orFilter);
	  }
	  if (to) {
	    api.searchParams.set('start_date', `lte.${to}`);
	  }
	  
	  console.debug('Events API URL:', api.toString());

      const res = await fetch(api, { headers: { apikey: key, Authorization: 'Bearer ' + key, Accept: 'application/json' }});
      if (!res.ok) throw new Error('Fetch failed: ' + res.status);
      const events = await res.json();
      
      // Fetch keywords for all events
      if (events && events.length > 0) {
        const eventIds = events.map(e => e.id).filter(id => id);
        if (eventIds.length > 0) {
          // Fetch event_keywords relationships - Supabase uses 'in' filter format: in.(id1,id2,id3)
          const relApi = new URL(url + '/rest/v1/event_keywords');
          relApi.searchParams.set('select', 'event_id,keyword_id');
          // Use PostgREST 'in' syntax: event_id=in.(uuid1,uuid2,...)
          const inFilter = eventIds.join(',');
          relApi.searchParams.set('event_id', `in.(${inFilter})`);
          
          const relRes = await fetch(relApi, { headers: { apikey: key, Authorization: 'Bearer ' + key, Accept: 'application/json' }});
          if (relRes.ok) {
            const relations = await relRes.json();
            const keywordIds = [...new Set(relations.map(r => r.keyword_id))];
            
            if (keywordIds.length > 0) {
              // Fetch keyword names
              const kwApi = new URL(url + '/rest/v1/keywords');
              kwApi.searchParams.set('select', 'id,name');
              const kwInFilter = keywordIds.join(',');
              kwApi.searchParams.set('id', `in.(${kwInFilter})`);
              
              const kwRes = await fetch(kwApi, { headers: { apikey: key, Authorization: 'Bearer ' + key, Accept: 'application/json' }});
              if (kwRes.ok) {
                const keywords = await kwRes.json();
                const keywordMap = new Map(keywords.map(kw => [kw.id, kw.name.toLowerCase()]));
                
                // Attach keywords to events
                const keywordsByEventId = new Map();
                relations.forEach(rel => {
                  const kwName = keywordMap.get(rel.keyword_id);
                  if (kwName) {
                    if (!keywordsByEventId.has(rel.event_id)) {
                      keywordsByEventId.set(rel.event_id, []);
                    }
                    keywordsByEventId.get(rel.event_id).push(kwName);
                  }
                });
                
                events.forEach(ev => {
                  ev.keywords = keywordsByEventId.get(ev.id) || [];
                });
              }
            }
          }
        }
      }
      
      return events;
    }

  function fmtRange(s, e){
    if (!s && !e) return '';
    if (s && !e) return s;
    if (!s && e) return e;
    return s === e ? s : `${s} â€“ ${e}`;
  }

  function formatEventDate(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      month: 'long', 
      day: 'numeric' 
    });
  }

  function getMonthName(dateString) {
    if (!dateString) return 'TBA';
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  }

  function getAllKeywords(rows) {
    const keywordSet = new Set();
    rows.forEach(ev => {
      if (ev.keywords && ev.keywords.length > 0) {
        ev.keywords.forEach(kw => keywordSet.add(kw));
      }
    });
    return Array.from(keywordSet).sort();
  }

  async function fetchAllKeywords({ url, key }) {
    try {
      const kwApi = new URL(url + '/rest/v1/keywords');
      kwApi.searchParams.set('select', 'id,name');
      kwApi.searchParams.set('order', 'name.asc');
      
      const kwRes = await fetch(kwApi, { 
        headers: { 
          apikey: key, 
          Authorization: 'Bearer ' + key, 
          Accept: 'application/json' 
        }
      });
      
      if (kwRes.ok) {
        const keywords = await kwRes.json();
        return keywords.map(kw => kw.name.toLowerCase()).sort();
      }
      return [];
    } catch (e) {
      console.error('Error fetching all keywords:', e);
      return [];
    }
  }

  function filterEventsByKeywords(events, selectedKeywords) {
    if (!selectedKeywords || selectedKeywords.length === 0) return events;
    return events.filter(ev => {
      if (!ev.keywords || ev.keywords.length === 0) return false;
      // AND logic: event must have ALL selected keywords
      return selectedKeywords.every(selectedKw => ev.keywords.includes(selectedKw));
    });
  }

  function filterEventsByDateRange(events, fromDate, toDate) {
    if (!fromDate && !toDate) return events;
    return events.filter(ev => {
      const startDate = ev.start_date;
      const endDate = ev.end_date || startDate;
      
      if (fromDate && endDate && endDate < fromDate) return false;
      if (toDate && startDate && startDate > toDate) return false;
      
      return true;
    });
  }

  function groupEventsByMonth(events) {
    const grouped = {};
    events.forEach(event => {
      const month = getMonthName(event.start_date);
      if (!grouped[month]) {
        grouped[month] = [];
      }
      grouped[month].push(event);
    });
    return grouped;
  }

  function renderListLayout(events, state) {
    const grouped = groupEventsByMonth(events);
    const months = Object.keys(grouped).sort((a, b) => {
      const dateA = new Date(grouped[a][0].start_date);
      const dateB = new Date(grouped[b][0].start_date);
      return dateA - dateB;
    });

    if (months.length === 0) {
      return '<div class="ssa-empty">No events found.</div>';
    }

    let html = '';
    months.forEach(month => {
      html += `<h3 class="ssa-month-header">${month}</h3>`;
      html += `<ul class="ssa-events-list">`;
      
      grouped[month].forEach((event, idx) => {
        const startDate = formatEventDate(event.start_date);
        const endDate = event.end_date ? formatEventDate(event.end_date) : '';
        const dateRange = endDate && startDate !== endDate ? `${startDate} - ${endDate}` : startDate;
        
        // Check if website_url exists and is not empty
        const hasWebsiteUrl = event.website_url && event.website_url.trim();
        const eventUrl = hasWebsiteUrl ? event.website_url.trim() : null;
        
        // Create unique event ID - use database ID if available, otherwise create hash
        const eventId = event.id ? `event-${event.id}` : `event-${btoa(event.name + (event.start_date || '')).replace(/[^a-zA-Z0-9]/g, '').substring(0, 10)}`;
        const hasImage = event.image_url && event.image_url.trim();
        
        html += `<li class="ssa-event-item" data-event-id="${eventId}" data-event-image="${hasImage ? event.image_url : ''}">`;
        html += `<div class="ssa-event-content">`;
        
        // Event image on the left
        if (hasImage) {
          html += `<div class="ssa-event-image-wrapper" data-event-id="${eventId}" data-image-url="${event.image_url}">`;
          html += `<img src="${event.image_url}" alt="${event.name}" class="ssa-event-image" />`;
          html += `</div>`;
        } else {
          // Placeholder space if no image
          html += `<div class="ssa-event-image-wrapper ssa-event-image-placeholder"></div>`;
        }
        
        // Event details on the right
        html += `<div class="ssa-event-details">`;
        html += `<span class="ssa-event-name-wrapper">`;
        
        // Info icon for description (only if description exists)
        const hasDescription = event.description && event.description.trim();
        if (hasDescription) {
          html += `<span class="ssa-info-icon" data-event-id="${eventId}" data-description="${event.description.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}" title="Hover to view description"></span>`;
        }
        
        // Event name - only make it a link if website_url exists
        const nameClasses = hasWebsiteUrl ? 'ssa-event-link' : 'ssa-event-name';
        
        if (hasWebsiteUrl) {
          html += `<a href="${eventUrl}" class="${nameClasses}" target="_blank" rel="noopener">`;
          html += `<strong>${event.name}</strong>`;
          html += `</a>`;
        } else {
          html += `<strong class="${nameClasses}">${event.name}</strong>`;
        }
        html += `</span>`;
        
        if (event.location) {
          html += ` <strong><span class="ssa-location" data-location="${event.location.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}" title="Click to open map in new tab, hover to preview">(${event.location})</span></strong>`;
        }
        if (event.host_org) {
          html += ` â€“ ${event.host_org}`;
        }
        if (dateRange) {
          html += ` â€“ ${dateRange}`;
        }
        html += `</div>`;
        
        // Keywords on their own line
        if (event.keywords && event.keywords.length > 0) {
          html += `<div class="ssa-event-keywords">`;
          html += event.keywords.map(kw => {
            const isSelected = state.selectedKeywords.includes(kw);
            return `<span class="ssa-keyword-tag-clickable ${isSelected ? 'ssa-keyword-tag-active' : ''}" data-keyword="${kw}">${kw}</span>`;
          }).join('');
          html += `</div>`;
        }
        
        html += `</div>`;
        html += `</li>`;
      });
      
      html += `</ul>`;
    });

    return html;
  }

  function renderGridLayout(events, state) {
    if (events.length === 0) {
      return '<div class="ssa-empty">No events found.</div>';
    }

    const selectedKeywords = state?.selectedKeywords || [];
    const cards = events.map(ev => {
      const hasImage = ev.image_url && ev.image_url.trim();
      const imageUrl = hasImage ? ev.image_url.trim() : '';
      const imageStyle = hasImage ? `style="--card-bg-image: url('${imageUrl.replace(/'/g, "\\'")}');"` : '';
      const eventId = ev.id ? `event-${ev.id}` : `event-${btoa(ev.name + (ev.start_date || '')).replace(/[^a-zA-Z0-9]/g, '').substring(0, 10)}`;
      return `
      <article class="ssa-card" ${hasImage ? `data-has-image="true"` : ''} ${imageStyle}>
        <div class="ssa-card-content">
          <header class="ssa-card-head">
            ${hasImage ? `<div class="ssa-card-image-icon" data-event-id="${eventId}" data-image-url="${imageUrl}" title="Hover to preview image"><img src="${imageUrl}" alt="${ev.name}" class="ssa-card-icon-thumb" /></div>` : ''}
            <h3 class="ssa-title">
              ${ev.description && ev.description.trim() ? `<span class="ssa-info-icon" data-event-id="${eventId}" data-description="${ev.description.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}" title="Hover to view description"></span>` : ''}
              ${ev.website_url ? `<a href="${ev.website_url}" class="ssa-event-link" target="_blank" rel="noopener">${ev.name}</a>` : `<span class="ssa-event-name">${ev.name}</span>`}
            </h3>
          </header>
          <p class="ssa-meta">${fmtRange(ev.start_date, ev.end_date)}${ev.location ? ' Â· <span class="ssa-location" data-location="' + ev.location.replace(/"/g, '&quot;').replace(/'/g, '&#39;') + '" title="Hover to view map">' + ev.location + '</span>' : ''}</p>
          ${ev.recurrence ? `<p class="ssa-meta">${ev.recurrence}</p>` : ''}
          ${ev.keywords && ev.keywords.length > 0 ? `<p class="ssa-keywords">${ev.keywords.map(kw => {
            const isSelected = selectedKeywords.includes(kw);
            return `<span class="ssa-tag-clickable ${isSelected ? 'ssa-tag-active' : ''}" data-keyword="${kw}">${kw}</span>`;
          }).join('')}</p>` : ''}
          ${ev.website_url ? `<p class="ssa-actions"><a class="ssa-link" href="${ev.website_url}" target="_blank" rel="noopener">Details</a></p>` : ''}
        </div>
      </article>
    `;
    }).join('');

    return `<div class="ssa-grid">${cards}</div>`;
  }

  async function renderEvents(mount, rows, state) {
    const { layout = LAYOUTS.LIST, selectedKeywords = [], fromDate = null, toDate = null } = state;
    
    // Store state on mount for handlers
    mount._currentState = state;
    
    // Apply filters
    let filteredRows = filterEventsByKeywords(rows, selectedKeywords);
    filteredRows = filterEventsByDateRange(filteredRows, fromDate, toDate);
    
    // Get keywords only from events that are actually loaded
    // This ensures we only show keywords that are used by at least one event
    const allKeywords = getAllKeywords(rows);
    
    // Render controls
    let controlsHTML = '<div class="ssa-controls">';
    
    // Layout switcher
    controlsHTML += '<div class="ssa-layout-switcher">';
    controlsHTML += `<button class="ssa-layout-btn ${layout === LAYOUTS.LIST ? 'ssa-active' : ''}" data-layout="${LAYOUTS.LIST}" title="List view">ðŸ“‹</button>`;
    controlsHTML += `<button class="ssa-layout-btn ${layout === LAYOUTS.GRID ? 'ssa-active' : ''}" data-layout="${LAYOUTS.GRID}" title="Grid view">âŠž</button>`;
    controlsHTML += '</div>';
    
    // Date range filters
    controlsHTML += '<div class="ssa-date-filters">';
    controlsHTML += `<label>From: <input type="date" class="ssa-date-input" id="ssa-from-date" value="${fromDate || ''}"></label>`;
    controlsHTML += `<label>To: <input type="date" class="ssa-date-input" id="ssa-to-date" value="${toDate || ''}"></label>`;
    controlsHTML += `<button class="ssa-clear-dates" title="Clear date filters">Clear</button>`;
    controlsHTML += '</div>';
    
    // Keyword filters - display all keywords from the system
    if (allKeywords.length > 0) {
      controlsHTML += '<div class="ssa-keyword-filters">';
      allKeywords.forEach(kw => {
        const isSelected = selectedKeywords.includes(kw);
        controlsHTML += `<button class="ssa-keyword-btn ${isSelected ? 'ssa-keyword-active' : ''}" data-keyword="${kw}">${kw}</button>`;
      });
      controlsHTML += '</div>';
    }
    
    controlsHTML += '</div>';
    
    // Render events based on layout
    let eventsHTML = '';
    if (layout === LAYOUTS.LIST) {
      eventsHTML = renderListLayout(filteredRows, state);
    } else if (layout === LAYOUTS.GRID) {
      eventsHTML = renderGridLayout(filteredRows, state);
    }
    
    mount.innerHTML = controlsHTML + eventsHTML;
    
    // Attach event handlers
    attachEventHandlers(mount, rows, state);
    
    // Inject styles if not already present
    injectStyles();
  }

  function attachEventHandlers(mount, rows, state) {
    // Layout switcher
    mount.querySelectorAll('.ssa-layout-btn').forEach(btn => {
      btn.addEventListener('click', async function() {
        const newLayout = this.dataset.layout;
        await renderEvents(mount, rows, { ...state, layout: newLayout });
      });
    });
    
    // Keyword filter buttons
    mount.querySelectorAll('.ssa-keyword-btn').forEach(btn => {
      btn.addEventListener('click', async function() {
        const keyword = this.dataset.keyword;
        const newSelected = state.selectedKeywords.includes(keyword)
          ? state.selectedKeywords.filter(k => k !== keyword)
          : [...state.selectedKeywords, keyword];
        await renderEvents(mount, rows, { ...state, selectedKeywords: newSelected });
      });
    });
    
    // Date inputs
    const fromInput = mount.querySelector('#ssa-from-date');
    const toInput = mount.querySelector('#ssa-to-date');
    const clearDatesBtn = mount.querySelector('.ssa-clear-dates');
    
    if (fromInput) {
      fromInput.addEventListener('change', async function() {
        const newFromDate = this.value || null;
        const newState = { ...state, fromDate: newFromDate };
        // Reload events if date filter changed
        if (mount._widgetOpts) {
          reloadEvents(mount, newState, mount._widgetOpts);
        } else {
          // Fallback: filter client-side if opts not available
          await renderEvents(mount, rows, newState);
        }
      });
    }
    
    if (toInput) {
      toInput.addEventListener('change', async function() {
        const newToDate = this.value || null;
        const newState = { ...state, toDate: newToDate };
        // Reload events if date filter changed
        if (mount._widgetOpts) {
          reloadEvents(mount, newState, mount._widgetOpts);
        } else {
          // Fallback: filter client-side if opts not available
          await renderEvents(mount, rows, newState);
        }
      });
    }
    
    if (clearDatesBtn) {
      clearDatesBtn.addEventListener('click', async function() {
        const newState = { ...state, fromDate: null, toDate: null };
        // Reload events to show all
        if (mount._widgetOpts) {
          reloadEvents(mount, newState, mount._widgetOpts);
        } else {
          // Fallback: filter client-side if opts not available
          await renderEvents(mount, rows, newState);
        }
      });
    }
    
    // Keyword tag clicks in list view
    if (state.layout === LAYOUTS.LIST) {
      mount.querySelectorAll('.ssa-keyword-tag-clickable').forEach(tag => {
        tag.addEventListener('click', async function() {
          const keyword = this.dataset.keyword;
          if (!keyword) return;
          
          // Toggle keyword in selected keywords
          const newSelected = state.selectedKeywords.includes(keyword)
            ? state.selectedKeywords.filter(k => k !== keyword)
            : [...state.selectedKeywords, keyword];
          
          await renderEvents(mount, rows, { ...state, selectedKeywords: newSelected });
        });
      });
    }
    
    // Keyword tag clicks in grid view
    if (state.layout === LAYOUTS.GRID) {
      mount.querySelectorAll('.ssa-tag-clickable').forEach(tag => {
        tag.addEventListener('click', async function() {
          const keyword = this.dataset.keyword;
          if (!keyword) return;
          
          // Toggle keyword in selected keywords
          const newSelected = state.selectedKeywords.includes(keyword)
            ? state.selectedKeywords.filter(k => k !== keyword)
            : [...state.selectedKeywords, keyword];
          
          await renderEvents(mount, rows, { ...state, selectedKeywords: newSelected });
        });
      });
    }
    
    // Image hover preview for grid view
    if (state.layout === LAYOUTS.GRID) {
      let hoverTimeout = null;
      let hoverPreviewEl = null;
      let hoverEventId = null;
      
      mount.querySelectorAll('.ssa-card-image-icon').forEach(icon => {
        const eventId = icon.dataset.eventId;
        const imageUrl = icon.dataset.imageUrl;
        if (!imageUrl || !imageUrl.trim()) return;
        
        icon.addEventListener('mouseenter', function(e) {
          if (hoverTimeout) clearTimeout(hoverTimeout);
          
          hoverTimeout = setTimeout(() => {
            const rect = icon.getBoundingClientRect();
            const gap = 8;
            const viewportH = window.innerHeight;
            const viewportW = window.innerWidth;
            const maxH = Math.min(800, viewportH - gap * 2);
            const maxW = Math.min(800, viewportW - gap * 2);
            
            let top = rect.top;
            // Position based on icon location
            if (rect.top < 120) {
              top = Math.max(gap, rect.top);
            } else if (rect.bottom > viewportH - 120) {
              top = Math.max(gap, rect.bottom - maxH);
            } else {
              top = rect.top + rect.height / 2 - maxH / 2;
            }
            top = Math.max(gap, Math.min(top, viewportH - maxH - gap));
            
            // Horizontal placement: prefer right, fallback to left, otherwise center
            const previewW = maxW;
            const spaceRight = viewportW - rect.right - gap;
            const spaceLeft = rect.left - gap;
            let left = rect.right + gap;
            if (spaceRight >= previewW) {
              left = rect.right + gap;
            } else if (spaceLeft >= previewW) {
              left = rect.left - gap - previewW;
            } else {
              left = Math.max(gap, Math.min(rect.left + rect.width / 2 - previewW / 2, viewportW - previewW - gap));
            }
            
            // Remove existing preview if any
            if (hoverPreviewEl) {
              hoverPreviewEl.remove();
            }
            
            // Create preview element
            hoverPreviewEl = document.createElement('div');
            hoverPreviewEl.className = 'ssa-image-preview';
            hoverPreviewEl.style.cssText = `
              position: fixed;
              top: ${top}px;
              left: ${left}px;
              z-index: 9999;
              padding: 6px;
              background: rgba(255,255,255,0.98);
              border: 1px solid #d1d5db;
              border-radius: 8px;
              box-shadow: 0 10px 30px rgba(0,0,0,.25);
              width: ${previewW}px;
            `;
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = 'Event preview';
            img.style.cssText = `
              width: auto;
              height: auto;
              max-width: ${previewW}px;
              max-height: ${maxH}px;
              border-radius: 6px;
              display: block;
            `;
            
            hoverPreviewEl.appendChild(img);
            document.body.appendChild(hoverPreviewEl);
            hoverEventId = eventId;
          }, 300); // Small delay to prevent flicker
        });
        
        icon.addEventListener('mouseleave', function() {
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          // Delay removal to allow moving to preview
          setTimeout(() => {
            if (hoverPreviewEl && hoverEventId === eventId) {
              hoverPreviewEl.remove();
              hoverPreviewEl = null;
              hoverEventId = null;
            }
          }, 100);
        });
      });
      
      // Also handle mouseleave on preview itself
      document.addEventListener('mouseenter', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-image-preview')) {
          if (hoverTimeout) clearTimeout(hoverTimeout);
        }
      }, true);
      
      document.addEventListener('mouseleave', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-image-preview')) {
          setTimeout(() => {
            if (hoverPreviewEl) {
              hoverPreviewEl.remove();
              hoverPreviewEl = null;
              hoverEventId = null;
            }
          }, 100);
        }
      }, true);
    }
    
    // Image hover preview for list view
    if (state.layout === LAYOUTS.LIST) {
      let hoverTimeout = null;
      let hoverPreviewEl = null;
      let hoverEventId = null;
      
      mount.querySelectorAll('.ssa-event-image-wrapper[data-image-url]').forEach(wrapper => {
        const eventId = wrapper.dataset.eventId;
        const imageUrl = wrapper.dataset.imageUrl;
        if (!imageUrl || !imageUrl.trim()) return;
        
        wrapper.addEventListener('mouseenter', function(e) {
          if (hoverTimeout) clearTimeout(hoverTimeout);
          
          hoverTimeout = setTimeout(() => {
            const rect = wrapper.getBoundingClientRect();
            const gap = 8;
            const viewportH = window.innerHeight;
            const viewportW = window.innerWidth;
            const maxH = Math.min(800, viewportH - gap * 2);
            const maxW = Math.min(800, viewportW - gap * 2);
            
            let top = rect.top;
            // Position based on thumbnail location
            if (rect.top < 120) {
              top = Math.max(gap, rect.top);
            } else if (rect.bottom > viewportH - 120) {
              top = Math.max(gap, rect.bottom - maxH);
            } else {
              top = rect.top + rect.height / 2 - maxH / 2;
            }
            top = Math.max(gap, Math.min(top, viewportH - maxH - gap));
            
            // Horizontal placement: prefer right, fallback to left, otherwise center
            const previewW = maxW;
            const spaceRight = viewportW - rect.right - gap;
            const spaceLeft = rect.left - gap;
            let left = rect.right + gap;
            if (spaceRight >= previewW) {
              left = rect.right + gap;
            } else if (spaceLeft >= previewW) {
              left = rect.left - gap - previewW;
            } else {
              left = Math.max(gap, Math.min(rect.left + rect.width / 2 - previewW / 2, viewportW - previewW - gap));
            }
            
            // Remove existing preview if any
            if (hoverPreviewEl) {
              hoverPreviewEl.remove();
            }
            
            // Create preview element
            hoverPreviewEl = document.createElement('div');
            hoverPreviewEl.className = 'ssa-image-preview';
            hoverPreviewEl.style.cssText = `
              position: fixed;
              top: ${top}px;
              left: ${left}px;
              z-index: 9999;
              padding: 6px;
              background: rgba(255,255,255,0.98);
              border: 1px solid #d1d5db;
              border-radius: 8px;
              box-shadow: 0 10px 30px rgba(0,0,0,.25);
              width: ${previewW}px;
            `;
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = 'Event preview';
            img.style.cssText = `
              width: auto;
              height: auto;
              max-width: ${previewW}px;
              max-height: ${maxH}px;
              border-radius: 6px;
              display: block;
            `;
            
            hoverPreviewEl.appendChild(img);
            document.body.appendChild(hoverPreviewEl);
            hoverEventId = eventId;
          }, 300); // Small delay to prevent flicker
        });
        
        wrapper.addEventListener('mouseleave', function() {
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          // Delay removal to allow moving to preview
          setTimeout(() => {
            if (hoverPreviewEl && hoverEventId === eventId) {
              hoverPreviewEl.remove();
              hoverPreviewEl = null;
              hoverEventId = null;
            }
          }, 100);
        });
      });
      
      // Also handle mouseleave on preview itself
      document.addEventListener('mouseenter', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-image-preview')) {
          if (hoverTimeout) clearTimeout(hoverTimeout);
        }
      }, true);
      
      document.addEventListener('mouseleave', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-image-preview')) {
          setTimeout(() => {
            if (hoverPreviewEl) {
              hoverPreviewEl.remove();
              hoverPreviewEl = null;
              hoverEventId = null;
            }
          }, 100);
        }
      }, true);
    }
    
    // Description popover on hover for info icons (list and grid views)
    let activePopover = null;
    let popoverTimeout = null;
    
    mount.querySelectorAll('.ssa-info-icon').forEach(element => {
      const description = element.dataset.description;
      if (!description || !description.trim()) return;
      
      // Decode HTML entities
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = description;
      const decodedDescription = tempDiv.textContent || tempDiv.innerText || description;
      
      element.addEventListener('mouseenter', function(e) {
        if (popoverTimeout) clearTimeout(popoverTimeout);
        
        // Remove any existing popover
        if (activePopover) {
          activePopover.remove();
          activePopover = null;
        }
        
        // Get element position
        const rect = element.getBoundingClientRect();
        
        // Create popover element
        const popover = document.createElement('div');
        popover.className = 'ssa-info-popover';
        popover.textContent = decodedDescription;
        document.body.appendChild(popover);
        
        // Get popover dimensions and viewport info
        const popoverRect = popover.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        const gap = 8;
        const minGapFromEdge = 10;
        
        // Calculate horizontal position (centered on element, but keep within viewport)
        let left = rect.left + (rect.width / 2) - (popoverRect.width / 2);
        if (left < minGapFromEdge) {
          left = minGapFromEdge;
        } else if (left + popoverRect.width > viewportWidth - minGapFromEdge) {
          left = viewportWidth - popoverRect.width - minGapFromEdge;
        }
        
        // Calculate vertical position - prefer above, but show below if not enough space
        let top = rect.top - popoverRect.height - gap;
        const spaceAbove = rect.top;
        const spaceBelow = viewportHeight - rect.bottom;
        
        // If not enough space above, position below instead
        if (top < minGapFromEdge || spaceAbove < popoverRect.height + gap + minGapFromEdge) {
          top = rect.bottom + gap;
          // If still doesn't fit below, position it at the top of viewport
          if (top + popoverRect.height > viewportHeight - minGapFromEdge) {
            top = minGapFromEdge;
          }
        }
        
        // Ensure popover doesn't go off bottom of viewport
        if (top + popoverRect.height > viewportHeight - minGapFromEdge) {
          top = viewportHeight - popoverRect.height - minGapFromEdge;
        }
        
        popover.style.position = 'fixed';
        popover.style.left = `${left}px`;
        popover.style.top = `${top}px`;
        popover.style.display = 'block';
        popover.style.zIndex = '10002';
        
        activePopover = popover;
      });
      
      element.addEventListener('mouseleave', function() {
        if (popoverTimeout) clearTimeout(popoverTimeout);
        popoverTimeout = setTimeout(() => {
          if (activePopover) {
            activePopover.remove();
            activePopover = null;
          }
        }, 100);
      });
      
      // Also handle mouseenter on popover itself
      document.addEventListener('mouseenter', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-info-popover')) {
          if (popoverTimeout) clearTimeout(popoverTimeout);
        }
      }, true);
      
      // Handle mouseleave on popover
      document.addEventListener('mouseleave', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-info-popover')) {
          if (popoverTimeout) clearTimeout(popoverTimeout);
          popoverTimeout = setTimeout(() => {
            if (activePopover) {
              activePopover.remove();
              activePopover = null;
            }
          }, 100);
        }
      }, true);
    });
    
    // Map popover on hover for location (list and grid views)
    // Use a shared variable scope for the popover state
    if (!window._ssaMapPopoverState) {
      window._ssaMapPopoverState = {
        activePopover: null,
        timeout: null
      };
    }
    
    const mapPopoverState = window._ssaMapPopoverState;
    const locationElements = mount.querySelectorAll('.ssa-location');
    
    locationElements.forEach(locationEl => {
      const location = locationEl.dataset.location;
      if (!location || !location.trim()) {
        return;
      }
      
      // Skip if already has handler (check for data attribute)
      if (locationEl.dataset.mapHandlerAttached === 'true') {
        return;
      }
      
      locationEl.dataset.mapHandlerAttached = 'true';
      locationEl.style.cursor = 'pointer';
      
      // Click handler to open map in new tab
      locationEl.addEventListener('click', function(e) {
        console.log('Location clicked:', location);
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        const encodedLocation = encodeURIComponent(location);
        const mapUrl = `https://www.google.com/maps/search/?api=1&query=${encodedLocation}`;
        console.log('Opening map URL:', mapUrl);
        const newWindow = window.open(mapUrl, '_blank', 'noopener,noreferrer');
        if (!newWindow) {
          console.log('Popup blocked, navigating directly');
          // If popup blocked, try direct navigation
          window.location.href = mapUrl;
        } else {
          console.log('Map opened in new tab successfully');
        }
        return false;
      }, true); // Use capture phase to ensure it fires first
      
      // Also handle clicks on parent elements (in case location is nested)
      const parent = locationEl.parentElement;
      if (parent && parent.tagName === 'STRONG') {
        parent.style.cursor = 'pointer';
        parent.addEventListener('click', function(e) {
          if (e.target === locationEl || locationEl.contains(e.target)) {
            console.log('Location clicked (via parent):', location);
            e.preventDefault();
            e.stopPropagation();
            const encodedLocation = encodeURIComponent(location);
            const mapUrl = `https://www.google.com/maps/search/?api=1&query=${encodedLocation}`;
            console.log('Opening map URL (via parent):', mapUrl);
            const newWindow = window.open(mapUrl, '_blank', 'noopener,noreferrer');
            if (!newWindow) {
              console.log('Popup blocked, navigating directly (via parent)');
              window.location.href = mapUrl;
            } else {
              console.log('Map opened in new tab successfully (via parent)');
            }
            return false;
          }
        }, true);
      }
      
      locationEl.addEventListener('mouseenter', function(e) {
        console.log('Location hovered:', location);
        e.stopPropagation();
        
        if (mapPopoverState.timeout) clearTimeout(mapPopoverState.timeout);
        
        // Remove any existing map popover
        if (mapPopoverState.activePopover) {
          mapPopoverState.activePopover.remove();
          mapPopoverState.activePopover = null;
        }
        
        // Get element position
        const rect = locationEl.getBoundingClientRect();
        
        // Create map popover element
        const mapPopover = document.createElement('div');
        mapPopover.className = 'ssa-map-popover';
        
        // Create iframe with map
        const mapIframe = document.createElement('iframe');
        const encodedLocation = encodeURIComponent(location);
        // Use Google Maps search URL with output=embed (works without API key)
        mapIframe.src = `https://www.google.com/maps?q=${encodedLocation}&output=embed`;
        mapIframe.style.width = '100%';
        mapIframe.style.height = '100%';
        mapIframe.style.border = '0';
        mapIframe.setAttribute('loading', 'lazy');
        mapIframe.setAttribute('allowfullscreen', '');
        mapIframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
        mapIframe.setAttribute('frameborder', '0');
        
        mapPopover.appendChild(mapIframe);
        document.body.appendChild(mapPopover);
        
        // Position map popover above the element (after it's in the DOM)
        const popoverWidth = 400;
        const popoverHeight = 300;
        const gap = 8;
        
        // Calculate horizontal position (center on element, but keep within viewport)
        let left = rect.left + (rect.width / 2) - (popoverWidth / 2);
        if (left < 10) left = 10;
        if (left + popoverWidth > window.innerWidth - 10) {
          left = window.innerWidth - popoverWidth - 10;
        }
        
        // Calculate vertical position (above element, but keep within viewport)
        let top = rect.top - popoverHeight - gap;
        if (top < 10) {
          top = rect.bottom + gap;
        }
        if (top + popoverHeight > window.innerHeight - 10) {
          top = window.innerHeight - popoverHeight - 10;
        }
        
        // Set all styles inline
        mapPopover.style.cssText = `
          position: fixed;
          left: ${left}px;
          top: ${top}px;
          display: block;
          z-index: 10003;
          width: 400px;
          height: 300px;
          padding: 0;
          background: #fff;
          border: 1px solid #d1d5db;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          overflow: hidden;
        `;
        
        mapPopoverState.activePopover = mapPopover;
      });
      
      locationEl.addEventListener('mouseleave', function() {
        if (mapPopoverState.timeout) clearTimeout(mapPopoverState.timeout);
        mapPopoverState.timeout = setTimeout(() => {
          if (mapPopoverState.activePopover) {
            mapPopoverState.activePopover.remove();
            mapPopoverState.activePopover = null;
          }
        }, 100);
      });
    });
    
    // Handle mouseenter/leave on map popover itself (use event delegation)
    if (!window._ssaMapPopoverHandlersAttached) {
      window._ssaMapPopoverHandlersAttached = true;
      
      document.addEventListener('mouseenter', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-map-popover')) {
          if (window._ssaMapPopoverState && window._ssaMapPopoverState.timeout) {
            clearTimeout(window._ssaMapPopoverState.timeout);
          }
        }
      }, true);
      
      document.addEventListener('mouseleave', function(e) {
        const target = e.target.nodeType === Node.ELEMENT_NODE ? e.target : e.target.parentElement;
        if (target && target.closest && target.closest('.ssa-map-popover')) {
          const mapState = window._ssaMapPopoverState;
          if (mapState && mapState.timeout) clearTimeout(mapState.timeout);
          if (mapState) {
            mapState.timeout = setTimeout(() => {
              if (mapState.activePopover) {
                mapState.activePopover.remove();
                mapState.activePopover = null;
              }
            }, 100);
          }
        }
      }, true);
    }
  }

  function injectStyles() {
    if (document.getElementById('ssa-styles-events')) return;
    
    const css = document.createElement('style');
    css.id = 'ssa-styles-events';
    css.textContent = `
      .ssa-controls{display:flex;flex-direction:column;gap:16px;margin-bottom:24px;padding-bottom:20px;border-bottom:1px solid #e5e7eb}
      .ssa-layout-switcher{display:flex;gap:4px}
      .ssa-layout-btn{padding:8px 12px;border:1px solid #d1d5db;border-radius:6px;background:#fff;color:#374151;cursor:pointer;font-size:1.2rem;transition:all 0.2s}
      .ssa-layout-btn:hover{background:#f9fafb;border-color:#9ca3af}
      .ssa-layout-btn.ssa-active{background:#3b82f6;border-color:#3b82f6;color:#fff}
      .ssa-date-filters{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
      .ssa-date-filters label{display:flex;align-items:center;gap:6px;font-size:0.875rem;color:#374151}
      .ssa-date-input{padding:6px 10px;border:1px solid #d1d5db;border-radius:4px;font-size:0.875rem}
      .ssa-clear-dates{padding:6px 12px;border:1px solid #d1d5db;border-radius:4px;background:#fff;color:#374151;cursor:pointer;font-size:0.875rem}
      .ssa-clear-dates:hover{background:#f9fafb}
      .ssa-keyword-filters{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
      .ssa-keyword-btn{padding:8px 16px;border:2px solid #d1d5db;border-radius:20px;background:#fff;color:#374151;cursor:pointer;font-size:0.875rem;font-weight:500;transition:all 0.2s}
      .ssa-keyword-btn:hover{background:#f9fafb;border-color:#9ca3af}
      .ssa-keyword-active{background:#374151;border-color:#374151;color:#fff}
      .ssa-keyword-active:hover{background:#1f2937;border-color:#1f2937}
      .ssa-empty{color:#6b7280;padding:20px;text-align:center}
      .ssa-skel{height:110px;border-radius:14px;background:linear-gradient(90deg,#f4f4f5,#f9fafb,#f4f4f5);background-size:200% 100%;animation:ssaShimmer 1.1s linear infinite}
      @keyframes ssaShimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}
      .ssa-month-header{margin:24px 0 12px;font-size:1.25rem;font-weight:600;color:#1f2937}
      .ssa-events-list{list-style:none;padding:0;margin:0 0 32px}
      .ssa-event-item{margin-bottom:12px;padding:12px 0;border-bottom:1px solid #f3f4f6}
      .ssa-event-item:last-child{border-bottom:none}
      .ssa-event-content{display:flex;gap:16px;align-items:flex-start}
      .ssa-event-image-wrapper{flex-shrink:0;width:60px;height:60px;border-radius:8px;overflow:hidden;background:#f3f4f6;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:opacity 0.2s}
      .ssa-event-image-wrapper:hover{opacity:0.9}
      .ssa-event-image-wrapper.ssa-event-image-placeholder{background:#f9fafb;border:1px dashed #d1d5db;cursor:default}
      .ssa-event-image{width:100%;height:100%;object-fit:cover;display:block}
      .ssa-event-details{flex:1;min-width:0}
      .ssa-event-name-wrapper{display:inline-flex;align-items:center;gap:6px}
      .ssa-event-link{color:#3b82f6;text-decoration:none;cursor:pointer}
      .ssa-event-link:hover{text-decoration:underline}
      .ssa-event-name{cursor:default}
      .ssa-info-icon{display:inline-flex!important;align-items:center;justify-content:center;font-size:0.7rem;opacity:0.8;cursor:help;margin-right:6px;transition:all 0.2s;flex-shrink:0;width:18px;height:18px;border-radius:50%;background:#3b82f6;color:#fff;font-weight:700;line-height:1;position:relative;vertical-align:middle}
      .ssa-info-icon::before{content:'i';font-style:normal;font-family:Georgia,serif;font-size:0.75rem}
      .ssa-info-icon:hover{opacity:1;background:#2563eb;transform:scale(1.15)}
      .ssa-info-popover{padding:12px;background:#fff;border:1px solid #d1d5db;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);min-width:200px;max-width:300px;max-height:400px;overflow-y:auto;font-size:0.875rem;line-height:1.5;color:#374151;white-space:normal;word-wrap:break-word;pointer-events:auto}
      .ssa-info-popover::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:#fff}
      .ssa-info-popover::before{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:7px solid transparent;border-top-color:#d1d5db;margin-top:-1px}
      .ssa-link-icon{display:inline-flex;align-items:center;justify-content:center;font-size:0.875rem;opacity:0.7;transition:opacity 0.2s;margin-left:4px}
      .ssa-link-icon:hover{opacity:1}
      .ssa-location{cursor:pointer;text-decoration:underline;text-decoration-style:dotted;text-underline-offset:2px;color:#3b82f6;transition:color 0.2s}
      .ssa-location:hover{color:#2563eb;text-decoration-style:solid}
      .ssa-map-popover{width:400px;height:300px;padding:0;background:#fff;border:1px solid #d1d5db;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);overflow:hidden;pointer-events:auto;position:fixed;z-index:10003}
      .ssa-map-popover::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:#fff;z-index:1}
      .ssa-map-popover::before{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:7px solid transparent;border-top-color:#d1d5db;margin-top:-1px;z-index:0}
      .ssa-keywords-inline{display:inline-flex;flex-wrap:wrap;gap:4px;margin-left:8px}
      .ssa-tag{display:inline-block;padding:2px 8px;background:#f3f4f6;border-radius:12px;font-size:0.75rem;color:#6b7280}
      .ssa-event-keywords{margin-top:8px;display:flex;flex-wrap:wrap;gap:6px}
      .ssa-keyword-tag-clickable{display:inline-block;padding:3px 10px;background:#f3f4f6;border-radius:12px;font-size:0.7rem;color:#6b7280;cursor:pointer;transition:all 0.2s;border:1px solid transparent}
      .ssa-keyword-tag-clickable:hover{background:#e5e7eb;border-color:#9ca3af;color:#374151}
      .ssa-keyword-tag-clickable.ssa-keyword-tag-active{background:#374151;border-color:#374151;color:#fff}
      .ssa-keyword-tag-clickable.ssa-keyword-tag-active:hover{background:#1f2937;border-color:#1f2937}
      .ssa-grid{display:grid;gap:16px}
      @media(min-width:720px){.ssa-grid{grid-template-columns:repeat(2,1fr)}}
      @media(min-width:1024px){.ssa-grid{grid-template-columns:repeat(3,1fr)}}
      .ssa-card{border:1px solid #e5e7eb;border-radius:14px;padding:0;background:#fff;position:relative;overflow:hidden}
      .ssa-card[data-has-image="true"]{background-color:#fff}
      .ssa-card[data-has-image="true"]::after{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background-image:var(--card-bg-image);background-size:cover;background-position:center;background-repeat:no-repeat;opacity:0.2;z-index:0}
      .ssa-card[data-has-image="true"]::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(to bottom,rgba(255,255,255,0.6) 0%,rgba(255,255,255,0.4) 50%,rgba(255,255,255,0.3) 100%);z-index:1}
      .ssa-card[data-has-image="true"] .ssa-card-content{position:relative;z-index:2;padding:14px}
      .ssa-card:not([data-has-image="true"]) .ssa-card-content{padding:14px}
      .ssa-card-content{min-height:120px}
      .ssa-card-head{display:flex;align-items:center;gap:8px;position:relative}
      .ssa-card-image-icon{display:inline-flex;align-items:center;justify-content:center;width:40px;height:40px;border-radius:6px;overflow:hidden;cursor:pointer;opacity:0.8;transition:opacity 0.2s;flex-shrink:0;z-index:10;border:2px solid rgba(0,0,0,0.1)}
      .ssa-card-image-icon:hover{opacity:1;border-color:rgba(0,0,0,0.2)}
      .ssa-card-icon-thumb{width:100%;height:100%;object-fit:cover;display:block}
      .ssa-title{margin:0;font-size:1.05rem;line-height:1.3;color:#1f2937;font-weight:600;flex:1;display:inline-flex;align-items:center;gap:4px}
      .ssa-meta{margin:.35rem 0;color:#374151;font-weight:500}
      .ssa-keywords{margin:.5rem 0;display:flex;flex-wrap:wrap;gap:4px}
      .ssa-tag-clickable{display:inline-block;padding:2px 8px;background:#f3f4f6;border-radius:12px;font-size:0.75rem;color:#6b7280;cursor:pointer;transition:all 0.2s;border:1px solid transparent}
      .ssa-tag-clickable:hover{background:#e5e7eb;border-color:#9ca3af;color:#374151}
      .ssa-tag-clickable.ssa-tag-active{background:#374151;border-color:#374151;color:#fff}
      .ssa-tag-clickable.ssa-tag-active:hover{background:#1f2937;border-color:#1f2937}
      .ssa-link{text-decoration:underline;color:#3b82f6;font-weight:500}
    `;
    document.head.appendChild(css);
  }

  // Helper function to reload events when filters change
  async function reloadEvents(mount, state, opts) {
    if (!opts || !opts.url || !opts.key) {
      console.error('reloadEvents: Missing required opts (url, key)', opts);
      // Fallback: try to use existing rows and filter client-side
      const existingRows = mount._allRows || [];
      await renderEvents(mount, existingRows, state);
      return;
    }
    
    try {
      const fetchOpts = {
        url: opts.url,
        key: opts.key,
        from: state.fromDate || null,
        to: state.toDate || null,
        limit: opts.limit || 200
      };
      const key = `ssa_events:${opts.url}:${fetchOpts.from || 'all'}:${fetchOpts.to || ''}:${opts.limit||200}`;
      const rows = await fetchEvents(fetchOpts);
      mount._allRows = rows; // Store for fallback
      sessionStorage.setItem(key, JSON.stringify(rows));
      await renderEvents(mount, rows, state);
    } catch (e) {
      console.error('Error reloading events:', e);
      // Fallback: try to use existing rows and filter client-side
      const existingRows = mount._allRows || [];
      if (existingRows.length > 0) {
        await renderEvents(mount, existingRows, state);
      } else {
        mount.innerHTML = `<div class="ssa-empty">Sorry, events are unavailable right now.</div>`;
      }
    }
  }

  async function renderEventsWidget(opts) {
    const mount = document.querySelector(opts.mount);
    if (!mount) return;
    
    // Initialize state - default fromDate to today
    const state = {
      layout: opts.layout || LAYOUTS.LIST,
      selectedKeywords: opts.selectedKeywords || [],
      fromDate: opts.fromDate !== undefined ? opts.fromDate : todayISO(),
      toDate: opts.toDate || null
    };
    
    // Store opts for reloadEvents
    mount._widgetOpts = opts;
    
    mount.innerHTML = `<div class="ssa-grid"><div class="ssa-skel"></div><div class="ssa-skel"></div><div class="ssa-skel"></div></div>`;
    
    try {
      // Fetch events with fromDate (or null if cleared)
      const fetchOpts = {
        ...opts,
        from: state.fromDate || null,
        to: state.toDate || null
      };
      const key = `ssa_events:${opts.url}:${fetchOpts.from || 'all'}:${fetchOpts.to || ''}:${opts.limit||200}`;
      const cached = sessionStorage.getItem(key);
      if (cached) {
        const cachedData = JSON.parse(cached);
        mount._allRows = cachedData; // Store for fallback in reloadEvents
        await renderEvents(mount, cachedData, state);
      }
      const rows = await fetchEvents(fetchOpts);
      mount._allRows = rows; // Store for fallback in reloadEvents
      sessionStorage.setItem(key, JSON.stringify(rows));
      await renderEvents(mount, rows, state);
    } catch (e) {
      console.error(e);
      mount.innerHTML = `<div class="ssa-empty">Sorry, events are unavailable right now.</div>`;
    }
  }

  window.SSWidgets = window.SSWidgets || {};
  window.SSWidgets.renderEvents = renderEventsWidget;
})();
</script>

<!-- 2) Mount + init call -->
<div id="events-list"></div>
<script>
  SSWidgets.renderEvents({
    mount: '#events-list',
    url: 'https://ydftcebaftngcdjvxrgl.supabase.co',
    key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlkZnRjZWJhZnRuZ2NkanZ4cmdsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1NDA5NDcsImV4cCI6MjA3NjExNjk0N30.8AlcsUMJSxBlua-ehaGLAn69bbORoMBdjM--MSxxXF0',
    //from: undefined,   // default = today (only ongoing/upcoming)
    //to: undefined,     // set like '2025-12-31' to cap the range if you want
    limit: 200
  });
</script>
